<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">
<link href="style.css" type="text/css" rel="stylesheet">
<title>PMOVZX — Packed Move with Zero Extend </title></head>
<body>
<h1>PMOVZX — Packed Move with Zero Extend</h1>
<table>
<tr>
<th>Opcode/Instruction</th>
<th>Op/En</th>
<th>64/32 bit Mode Support</th>
<th>CPUID Feature Flag</th>
<th>Description</th></tr>
<tr>
<td>66 0f 38 30 /r PMOVZXBW<em> xmm1, xmm2/m64</em></td>
<td>RM</td>
<td>V/V</td>
<td>SSE4_1</td>
<td>Zero extend 8 packed 8-bit integers in the low 8 bytes of <em>xmm2/m64 </em>to 8 packed 16-bit integers in<em> xmm1</em>.</td></tr>
<tr>
<td>66 0f 38 31 /r PMOVZXBD<em> xmm1, xmm2/m32</em></td>
<td>RM</td>
<td>V/V</td>
<td>SSE4_1</td>
<td>Zero extend 4 packed 8-bit integers in the low 4 bytes of <em>xmm2/m32</em> to 4 packed 32-bit integers in<em> xmm1.</em></td></tr>
<tr>
<td>66 0f 38 32 /r PMOVZXBQ <em>xmm1, xmm2/m16</em></td>
<td>RM</td>
<td>V/V</td>
<td>SSE4_1</td>
<td>Zero extend 2 packed 8-bit integers in the low 2 bytes of <em>xmm2/m16</em> to 2 packed 64-bit integers in <em>xmm1</em>.</td></tr>
<tr>
<td>66 0f 38 33 /r PMOVZXWD <em>xmm1, xmm2/m64</em></td>
<td>RM</td>
<td>V/V</td>
<td>SSE4_1</td>
<td>Zero extend 4 packed 16-bit integers in the low 8 bytes of<em> xmm2/m64</em> to 4 packed 32-bit integers in <em>xmm1</em>.</td></tr>
<tr>
<td>66 0f 38 34 /r PMOVZXWQ <em>xmm1, xmm2/m32</em></td>
<td>RM</td>
<td>V/V</td>
<td>SSE4_1</td>
<td>Zero extend 2 packed 16-bit integers in the low 4 bytes of<em> xmm2/m32</em> to 2 packed 64-bit integers in<em> xmm1</em>.</td></tr>
<tr>
<td>66 0f 38 35 /r PMOVZXDQ <em>xmm1, xmm2/m64</em></td>
<td>RM</td>
<td>V/V</td>
<td>SSE4_1</td>
<td>Zero extend 2 packed 32-bit integers in the low 8 bytes of<em> xmm2/m64</em> to 2 packed 64-bit integers in <em>xmm1</em>.</td></tr>
<tr>
<td>VEX.128.66.0F38.WIG 30 /r VPMOVZXBW <em>xmm1, xmm2/m64</em></td>
<td>RM</td>
<td>V/V</td>
<td>AVX</td>
<td>Zero extend 8 packed 8-bit integers in the low 8 bytes of <em>xmm2/m64</em> to 8 packed 16-bit integers in <em>xmm1</em>.</td></tr>
<tr>
<td>VEX.128.66.0F38.WIG 31 /r VPMOVZXBD <em>xmm1, xmm2/m32</em></td>
<td>RM</td>
<td>V/V</td>
<td>AVX</td>
<td>Zero extend 4 packed 8-bit integers in the low 4 bytes of <em>xmm2/m32</em> to 4 packed 32-bit integers in <em>xmm1</em>.</td></tr>
<tr>
<td>VEX.128.66.0F38.WIG 32 /r VPMOVZXBQ<em> xmm1, xmm2/m16</em></td>
<td>RM</td>
<td>V/V</td>
<td>AVX</td>
<td>Zero extend 2 packed 8-bit integers in the low 2 bytes of <em>xmm2/m16</em> to 2 packed 64-bit integers in <em>xmm1</em>.</td></tr>
<tr>
<td>VEX.128.66.0F38.WIG 33 /r VPMOVZXWD <em>xmm1, xmm2/m64</em></td>
<td>RM</td>
<td>V/V</td>
<td>AVX</td>
<td>Zero extend 4 packed 16-bit integers in the low 8 bytes of <em>xmm2/m64</em> to 4 packed 32-bit integers in <em>xmm1</em>.</td></tr>
<tr>
<td>VEX.128.66.0F38.WIG 34 /r VPMOVZXWQ <em>xmm1, xmm2/m32</em></td>
<td>RM</td>
<td>V/V</td>
<td>AVX</td>
<td>Zero extend 2 packed 16-bit integers in the low 4 bytes of <em>xmm2/m32</em> to 2 packed 64-bit integers in <em>xmm1</em>.</td></tr>
<tr>
<td>VEX.128.66.0F38.WIG 35 /r VPMOVZXDQ <em>xmm1, xmm2/m64</em></td>
<td>RM</td>
<td>V/V</td>
<td>AVX</td>
<td>Zero extend 2 packed 32-bit integers in the low 8 bytes of <em>xmm2/m64</em> to 2 packed 64-bit integers in <em>xmm1</em>.</td></tr>
<tr>
<td>VEX.256.66.0F38.WIG 30 /r VPMOVZXBW <em>ymm1, xmm2/m128</em></td>
<td>RM</td>
<td>V/V</td>
<td>AVX2</td>
<td>Zero extend 16 packed 8-bit integers in the low 16 bytes of <em>xmm2/m128</em> to 16 packed 16-bit integers in <em>ymm1</em>.</td></tr>
<tr>
<td>VEX.256.66.0F38.WIG 31 /r VPMOVZXBD <em>ymm1, xmm2/m64</em></td>
<td>RM</td>
<td>V/V</td>
<td>AVX2</td>
<td>Zero extend 8 packed 8-bit integers in the low 8 bytes of <em>xmm2/m64</em> to 8 packed 32-bit integers in <em>ymm1</em>.</td></tr>
<tr>
<td>VEX.256.66.0F38.WIG 32 /r VPMOVZXBQ <em>ymm1, xmm2/m32</em></td>
<td>RM</td>
<td>V/V</td>
<td>AVX2</td>
<td>Zero extend 4 packed 8-bit integers in the low 4 bytes of <em>xmm2/m32</em> to 4 packed 64-bit integers in <em>ymm1</em>.</td></tr>
<tr>
<td>VEX.256.66.0F38.WIG 33 /r VPMOVZXWD <em>ymm1, xmm2/m128</em></td>
<td>RM</td>
<td>V/V</td>
<td>AVX2</td>
<td>Zero extend 8 packed 16-bit integers in the low 16 bytes of <em>xmm2/m128</em> to 8 packed 32-bit integers in <em>ymm1</em>.</td></tr></table>
<table>
<tr>
<th>Opcode/Instruction</th>
<th>Op/En</th>
<th>64/32 bit Mode Support</th>
<th>CPUID Feature Flag</th>
<th>Description</th></tr>
<tr>
<td>VEX.256.66.0F38.WIG 34 /r VPMOVZXWQ <em>ymm1, xmm2/m64</em></td>
<td>RM</td>
<td>V/V</td>
<td>AVX2</td>
<td>Zero extend 4 packed 16-bit integers in the low 8 bytes of <em>xmm2/m64</em> to 4 packed 64-bit integers in <em>xmm1</em>.</td></tr>
<tr>
<td>VEX.256.66.0F38.WIG 35 /r VPMOVZXDQ <em>ymm1, xmm2/m128</em></td>
<td>RM</td>
<td>V/V</td>
<td>AVX2</td>
<td>Zero extend 4 packed 32-bit integers in the low 16 bytes of <em>xmm2/m128</em> to 4 packed 64-bit integers in <em>ymm1</em>.</td></tr></table>
<h3>Instruction Operand Encoding</h3>
<table>
<tr>
<td>Op/En</td>
<td>Operand 1</td>
<td>Operand 2</td>
<td>Operand 3</td>
<td>Operand 4</td></tr>
<tr>
<td>RM</td>
<td>ModRM:reg (w)</td>
<td>ModRM:r/m (r)</td>
<td>NA</td>
<td>NA</td></tr></table>
<h2>Description</h2>
<p>Zero-extend the low byte/word/dword values in each word/dword/qword element of the source operand (second operand) to word/dword/qword integers and stored as packed data in the destination operand (first operand).</p>
<p>128-bit Legacy SSE version: Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.</p>
<p>VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p>
<p>VEX.256 encoded version: The destination register is YMM Register.</p>
<p>Note: VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD.</p>
<h2>Operation</h2>
<p><strong>PMOVZXBW</strong></p>
<pre>    DEST[15:0] ← ZeroExtend(SRC[7:0]);
    DEST[31:16] ← ZeroExtend(SRC[15:8]);
    DEST[47:32] ← ZeroExtend(SRC[23:16]);
    DEST[63:48] ← ZeroExtend(SRC[31:24]);
    DEST[79:64] ← ZeroExtend(SRC[39:32]);
    DEST[95:80] ← ZeroExtend(SRC[47:40]);
    DEST[111:96] ← ZeroExtend(SRC[55:48]);
    DEST[127:112] ← ZeroExtend(SRC[63:56]);</pre>
<p><strong>PMOVZXBD</strong></p>
<pre>    DEST[31:0] ← ZeroExtend(SRC[7:0]);
    DEST[63:32] ← ZeroExtend(SRC[15:8]);
    DEST[95:64] ← ZeroExtend(SRC[23:16]);
    DEST[127:96] ← ZeroExtend(SRC[31:24]);</pre>
<p><strong>PMOVZXQB</strong></p>
<pre>    DEST[63:0] ← ZeroExtend(SRC[7:0]);
    DEST[127:64] ← ZeroExtend(SRC[15:8]);</pre>
<p><strong>PMOVZXWD</strong></p>
<pre>    DEST[31:0] ← ZeroExtend(SRC[15:0]);
    DEST[63:32] ← ZeroExtend(SRC[31:16]);
    DEST[95:64] ← ZeroExtend(SRC[47:32]);
    DEST[127:96] ← ZeroExtend(SRC[63:48]);</pre>
<p><strong>PMOVZXWQ</strong></p>
<pre>    DEST[63:0] ← ZeroExtend(SRC[15:0]);
    DEST[127:64] ← ZeroExtend(SRC[31:16]);</pre>
<p><strong>PMOVZXDQ</strong></p>
<pre>    DEST[63:0] ← ZeroExtend(SRC[31:0]);
    DEST[127:64] ← ZeroExtend(SRC[63:32]);</pre>
<p><strong>VPMOVZXBW (VEX.128 encoded version)</strong></p>
<pre>Packed_Zero_Extend_BYTE_to_WORD()
DEST[VLMAX-1:128] ← 0</pre>
<p><strong>VPMOVZXBD (VEX.128 encoded version)</strong></p>
<pre>Packed_Zero_Extend_BYTE_to_DWORD()
DEST[VLMAX-1:128] ← 0</pre>
<p><strong>VPMOVZXBQ (VEX.128 encoded version)</strong></p>
<pre>Packed_Zero_Extend_BYTE_to_QWORD()
DEST[VLMAX-1:128] ← 0</pre>
<p><strong>VPMOVZXWD (VEX.128 encoded version)</strong></p>
<pre>Packed_Zero_Extend_WORD_to_DWORD()
DEST[VLMAX-1:128] ← 0</pre>
<p><strong>VPMOVZXWQ (VEX.128 encoded version)</strong></p>
<pre>Packed_Zero_Extend_WORD_to_QWORD()
DEST[VLMAX-1:128] ← 0</pre>
<p><strong>VPMOVZXDQ (VEX.128 encoded version)</strong></p>
<pre>Packed_Zero_Extend_DWORD_to_QWORD()
DEST[VLMAX-1:128] ← 0</pre>
<p><strong>VPMOVZXBW (VEX.256 encoded version)</strong></p>
<pre>Packed_Zero_Extend_BYTE_to_WORD(DEST[127:0], SRC[63:0])
Packed_Zero_Extend_BYTE_to_WORD(DEST[255:128], SRC[127:64])</pre>
<p><strong>VPMOVZXBD (VEX.256 encoded version)</strong></p>
<pre>Packed_Zero_Extend_BYTE_to_DWORD(DEST[127:0], SRC[31:0])
Packed_Zero_Extend_BYTE_to_DWORD(DEST[255:128], SRC[63:32])</pre>
<p><strong>VPMOVZXBQ (VEX.256 encoded version)</strong></p>
<pre>Packed_Zero_Extend_BYTE_to_QWORD(DEST[127:0], SRC[15:0])
Packed_Zero_Extend_BYTE_to_QWORD(DEST[255:128], SRC[31:16])</pre>
<p><strong>VPMOVZXWD (VEX.256 encoded version)</strong></p>
<pre>Packed_Zero_Extend_WORD_to_DWORD(DEST[127:0], SRC[63:0])
Packed_Zero_Extend_WORD_to_DWORD(DEST[255:128], SRC[127:64])</pre>
<p><strong>VPMOVZXWQ (VEX.256 encoded version)</strong></p>
<pre>Packed_Zero_Extend_WORD_to_QWORD(DEST[127:0], SRC[31:0])
Packed_Zero_Extend_WORD_to_QWORD(DEST[255:128], SRC[63:32])</pre>
<p><strong>VPMOVZXDQ (VEX.256 encoded version)</strong></p>
<pre>Packed_Zero_Extend_DWORD_to_QWORD(DEST[127:0], SRC[63:0])
Packed_Zero_Extend_DWORD_to_QWORD(DEST[255:128], SRC[127:64])</pre>
<h2>Flags Affected</h2>
<p>None</p>
<h2>Intel C/C++ Compiler Intrinsic Equivalent</h2>
<p>(V)PMOVZXBW:</p>
<p>__m128i _mm_ cvtepu8_epi16 ( __m128i a);</p>
<p>VPMOVZXBW:</p>
<p>__m256i _mm256_cvtepu8_epi16 ( __m128i a);</p>
<p>(V)PMOVZXBD:</p>
<p>__m128i _mm_ cvtepu8_epi32 ( __m128i a);</p>
<p>VPMOVZXBD:</p>
<p>__m256i _mm256_cvtepu8_epi32 ( __m128i a);</p>
<p>(V)PMOVZXBQ:</p>
<p>__m128i _mm_ cvtepu8_epi64 ( __m128i a);</p>
<p>VPMOVZXBQ:</p>
<p>__m256i _mm256_cvtepu8_epi64 ( __m128i a);</p>
<p>(V)PMOVZXWD:</p>
<p>__m128i _mm_ cvtepu16_epi32 ( __m128i a);</p>
<p>VPMOVZXWD:</p>
<p>__m256i _mm256_cvtepu16_epi32 ( __m128i a);</p>
<p>(V)PMOVZXWQ:</p>
<p>__m128i _mm_ cvtepu16_epi64 ( __m128i a);</p>
<p>VPMOVZXWQ:</p>
<p>__m256i _mm256_cvtepu16_epi64 ( __m128i a);</p>
<p>(V)PMOVZXDQ:</p>
<p>__m128i _mm_ cvtepu32_epi64 ( __m128i a);</p>
<p>VPMOVZXDQ:</p>
<p> __m256i _mm256_cvtepu32_epi64 ( __m128i a);</p>
<h2>Flags Affected</h2>
<p>None.</p>
<h2>SIMD Floating-Point Exceptions</h2>
<p>None.</p>
<h2>Other Exceptions</h2>
<p>See Exceptions Type 5; additionally</p>
<table class="exception-table">
<tr>
<td>#UD</td>
<td>
<p>If VEX.L = 1.</p>
<p>If VEX.vvvv ≠ 1111B.</p></td></tr></table></body></html>
<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">
<link href="style.css" type="text/css" rel="stylesheet">
<title>PREFETCHW—Prefetch Data into Caches in Anticipation of a Write </title></head>
<body>
<h1>PREFETCHW—Prefetch Data into Caches in Anticipation of a Write</h1>
<table>
<tr>
<th>Opcode/Instruction</th>
<th>Op/En</th>
<th>64/32 bit Mode Support</th>
<th>CPUID Feature Flag</th>
<th>Description</th></tr>
<tr>
<td>0F 0D /1 PREFETCHW m8</td>
<td>A</td>
<td>V/V</td>
<td>PRFCHW</td>
<td>Move data from m8 closer to the processor in anticipation of a write.</td></tr></table>
<h3>Instruction Operand Encoding</h3>
<table>
<tr>
<td>Op/En</td>
<td>Operand 1</td>
<td>Operand 2</td>
<td>Operand 3</td>
<td>Operand 4</td></tr>
<tr>
<td>M</td>
<td>ModRM:r/m (r)</td>
<td>NA</td>
<td>NA</td>
<td>NA</td></tr></table>
<h2>Description</h2>
<p>Fetches the cache line of data from memory that contains the byte specified with the source operand to a location in the 1st or 2nd level cache and invalidates all other cached instances of the line.</p>
<p>The source operand is a byte memory location. If the line selected is already present in the lowest level cache and is already in an exclusively owned state, no data movement occurs. Prefetches from non-writeback memory are ignored.</p>
<p>The PREFETCHW instruction is merely a hint and does not affect program behavior. If executed, this instruction moves data closer to the processor and invalidates any other cached copy in anticipation of the line being written to in the future.</p>
<p>The characteristic of prefetch locality hints is implementation-dependent, and can be overloaded or ignored by a processor implementation. The amount of data prefetched is also processor implementation-dependent. It will, however, be a minimum of 32 bytes.</p>
<p>It should be noted that processors are free to speculatively fetch and cache data with exclusive ownership from system memory regions that permit such accesses (that is, the WB memory type). A PREFETCHW instruction is considered a hint to this speculative behavior. Because this speculative fetching can occur at any time and is not tied to instruction execution, a PREFETCHW instruction is not ordered with respect to the fence instructions (MFENCE, SFENCE, and LFENCE) or locked memory references. A PREFETCHW instruction is also unordered with respect to CLFLUSH instructions, other PREFETCHW instructions, or any other general instruction</p>
<p>It is ordered with respect to serializing instructions such as CPUID, WRMSR, OUT, and MOV CR.</p>
<p>This instruction's operation is the same in non-64-bit modes and 64-bit mode.</p>
<h2>Operation</h2>
<pre>FETCH_WITH_EXCLUSIVE_OWNERSHIP (m8);</pre>
<h2>Flags Affected</h2>
<p>All flags are affected</p>
<h2>C/C++ Compiler Intrinsic Equivalent</h2>
<p>void _m_prefetchw( void * );</p>
<h2>Protected Mode Exceptions</h2>
<table class="exception-table">
<tr>
<td>#UD</td>
<td>If the LOCK prefix is used.</td></tr></table>
<h2>Real-Address Mode Exceptions</h2>
<table class="exception-table">
<tr>
<td>#UD</td>
<td>If the LOCK prefix is used.</td></tr></table>
<h2>Virtual-8086 Mode Exceptions</h2>
<table class="exception-table">
<tr>
<td>#UD</td>
<td>If the LOCK prefix is used.</td></tr></table>
<h2>Compatibility Mode Exceptions</h2>
<table class="exception-table">
<tr>
<td>#UD</td>
<td>If the LOCK prefix is used.</td></tr></table>
<h2>64-Bit Mode Exceptions</h2>
<table class="exception-table">
<tr>
<td>#UD</td>
<td>If the LOCK prefix is used.</td></tr></table></body></html>
<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">
<link href="style.css" type="text/css" rel="stylesheet">
<title>MOVNTDQA — Load Double Quadword Non-Temporal Aligned Hint </title></head>
<body>
<h1>MOVNTDQA — Load Double Quadword Non-Temporal Aligned Hint</h1>
<table>
<tr>
<th>Opcode/Instruction</th>
<th>Op/En</th>
<th>64/32-bit Mode</th>
<th>CPUID Feature Flag</th>
<th>Description</th></tr>
<tr>
<td>
<p>66 0F 38 2A /r</p>
<p>MOVNTDQA <em>xmm1, m128</em></p></td>
<td>RM</td>
<td>V/V</td>
<td>SSE4_1</td>
<td>Move double quadword from <em>m128 </em>to <em>xmm </em>using non-temporal hint if WC memory type.</td></tr>
<tr>
<td>
<p>VEX.128.66.0F38.WIG 2A /r</p>
<p>VMOVNTDQA <em>xmm1, m128</em></p></td>
<td>RM</td>
<td>V/V</td>
<td>AVX</td>
<td>Move double quadword from <em>m128</em> to <em>xmm </em>using non-temporal hint if WC memory type.</td></tr>
<tr>
<td>
<p>VEX.256.66.0F38.WIG 2A /r</p>
<p>VMOVNTDQA <em>ymm1, m256</em></p></td>
<td>RM</td>
<td>V/V</td>
<td>AVX2</td>
<td>Move 256-bit data from <em>m256</em> to ymm using non-temporal hint if WC memory type.</td></tr></table>
<h3>Instruction Operand Encoding</h3>
<table>
<tr>
<td>Op/En</td>
<td>Operand 1</td>
<td>Operand 2</td>
<td>Operand 3</td>
<td>Operand 4</td></tr>
<tr>
<td>RM</td>
<td>ModRM:reg (w)</td>
<td>ModRM:r/m (r)</td>
<td>NA</td>
<td>NA</td></tr></table>
<h2>Description</h2>
<p>(V)MOVNTDQA loads a double quadword from the source operand (second operand) to the destination operand (first operand) using a non-temporal hint. A processor implementation may make use of the non-temporal hint associated with this instruction if the memory source is WC (write combining) memory type. An implementation may also make use of the non-temporal hint associated with this instruction if the memory source is WB (write back) memory type.</p>
<p>A processor’s implementation of the non-temporal hint does not override the effective memory type semantics, but the implementation of the hint is processor dependent. For example, a processor implementation may choose to ignore the hint and process the instruction as a normal MOVDQA for any memory type. Another implementation of the hint for WC memory type may optimize data transfer throughput of WC reads. A third implementation may optimize cache reads generated by (V)MOVNTDQA on WB memory type to reduce cache evictions.</p>
<p><strong>WC Streaming Load Hint</strong></p>
<p>For WC memory type in particular, the processor never appears to read the data into the cache hierarchy. Instead, the non-temporal hint may be implemented by loading a temporary internal buffer with the equivalent of an aligned cache line without filling this data to the cache. Any memory-type aliased lines in the cache will be snooped and flushed. Subsequent MOVNTDQA reads to unread portions of the WC cache line will receive data from the temporary internal buffer if data is available. The temporary internal buffer may be flushed by the processor at any time for any reason, for example:</p>
<p>The memory type of the region being read can override the non-temporal hint, if the memory address specified for the non-temporal read is not a WC memory region. Information on non-temporal reads and writes can be found in Chapter 11, “Memory Cache Control” of <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A</em>.</p>
<p>Because the WC protocol uses a weakly-ordered memory consistency model, an MFENCE or locked instruction should be used in conjunction with MOVNTDQA instructions if multiple processors might reference the same WC memory locations or in order to synchronize reads of a processor with writes by other agents in the system. Because of the speculative nature of fetching due to MOVNTDQA, Streaming loads must not be used to reference memory addresses that are mapped to I/O devices having side effects or when reads to these devices are destruc-</p>
<p>tive. For additional information on MOVNTDQA usages, see Section 12.10.3 in Chapter 12, “Programming with SSE3, SSSE3 and SSE4” of <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>.</p>
<p>The 128-bit (V)MOVNTDQA addresses must be 16-byte aligned or the instruction will cause a #GP.</p>
<p>The 256-bit VMOVNTDQA addresses must be 32-byte aligned or the instruction will cause a #GP.</p>
<p>Note: In VEX-128 encoded versions, VEX.vvvv is reserved and must be 1111b, VEX.L must be 0; otherwise instruc-tions will #UD.</p>
<h2>Operation</h2>
<p><strong>MOVNTDQA (128bit- Legacy SSE form)</strong></p>
<pre>DEST ← SRC
DEST[VLMAX-1:128] (Unmodified)</pre>
<p><strong>VMOVNTDQA (VEX.128 encoded form)</strong></p>
<pre>DEST ← SRC
DEST[VLMAX-1:128] ← 0</pre>
<p><strong>VMOVNTDQA (VEX.256 encoded form)</strong></p>
<pre>DEST[255:0] ← SRC[255:0]</pre>
<h2>Intel C/C++ Compiler Intrinsic Equivalent</h2>
<p>(V)MOVNTDQA:</p>
<p>__m128i _mm_stream_load_si128 (__m128i *p);</p>
<p>VMOVNTDQA:</p>
<p> __m256i _mm256_stream_load_si256 (const __m256i *p);</p>
<h2>Flags Affected</h2>
<p>None</p>
<h2>Other Exceptions</h2>
<p>See Exceptions Type 1.SSE4.1; additionally</p>
<table class="exception-table">
<tr>
<td>#UD</td>
<td>
<p>If VEX.L= 1.</p>
<p>If VEX.vvvv ≠ 1111B.</p></td></tr></table></body></html>